#!/usr/bin/env python
# coding=utf-8
"""
Unit tests for asynchronous tool support in Code Minion Python executor
"""

import asyncio
import pytest
from minion.main.async_python_executor import AsyncPythonExecutor
from minion.tools.async_example_tools import EXAMPLE_ASYNC_TOOLS
from minion.tools.base_tool import tool


@tool 
def sync_test_tool(x: int, y: int) -> int:
    """Simple sync tool for testing"""
    return x + y


class TestAsyncBaseTool:
    """Test AsyncBaseTool functionality"""
    
    @pytest.mark.asyncio
    async def test_async_tool_creation(self):
        """Test that async tools can be created and called"""
        from minion.tools.async_example_tools import AsyncDatabaseTool
        
        tool = AsyncDatabaseTool()
        assert tool.name == "async_database"
        assert tool.description == "Simulate asynchronous database operations"
        
        result = await tool("SELECT * FROM test", "SELECT")
        assert result["operation"] == "SELECT"
        assert "results" in result
    
    @pytest.mark.asyncio 
    async def test_async_tool_decorator(self):
        """Test @async_tool decorator"""
        from minion.tools.async_base_tool import async_tool
        
        @async_tool
        async def test_async_func(value: int) -> int:
            """Test async function"""
            await asyncio.sleep(0.01)
            return value * 2
        
        result = await test_async_func(5)
        assert result == 10


class TestAsyncPythonExecutor:
    """Test AsyncPythonExecutor functionality"""
    
    def setup_method(self):
        """Setup executor for each test"""
        self.executor = AsyncPythonExecutor(
            additional_authorized_imports=["asyncio"],
            max_print_outputs_length=1000
        )
    
    @pytest.mark.asyncio
    async def test_executor_creation(self):
        """Test executor can be created"""
        assert self.executor is not None
        assert self.executor.state["__name__"] == "__main__"
    
    @pytest.mark.asyncio
    async def test_simple_async_execution(self):
        """Test simple async code execution"""
        self.executor.send_tools({"async_calculate_pi": EXAMPLE_ASYNC_TOOLS["async_calculate_pi"]})
        
        code = "result = await async_calculate_pi(10)"
        output, logs, is_final = await self.executor(code)
        
        # Pi approximation should be close to actual value
        assert abs(output - 3.14159) < 1.0  # Very rough approximation with 10 iterations
    
    @pytest.mark.asyncio
    async def test_sync_async_tool_mixing(self):
        """Test mixing sync and async tools"""
        tools = {
            "sync_test_tool": sync_test_tool,
            "async_fetch_data": EXAMPLE_ASYNC_TOOLS["async_fetch_data"]
        }
        self.executor.send_tools(tools)
        
        code = """
sync_result = sync_test_tool(3, 4)
async_result = await async_fetch_data("test", 0.01)
final_result = sync_result + len(async_result["data"])
"""
        
        output, logs, is_final = await self.executor(code)
        assert output > 7  # 3+4 plus some data length
    
    @pytest.mark.asyncio
    async def test_concurrent_execution(self):
        """Test concurrent async tool execution"""
        self.executor.send_tools({"async_fetch_data": EXAMPLE_ASYNC_TOOLS["async_fetch_data"]})
        
        code = """
import asyncio
tasks = [
    async_fetch_data("url1", 0.01),
    async_fetch_data("url2", 0.01)
]
results = await asyncio.gather(*tasks)
final_count = len(results)
"""
        
        output, logs, is_final = await self.executor(code)
        assert output == 2  # Two results from gather
    
    @pytest.mark.asyncio
    async def test_error_handling(self):
        """Test error handling in async execution"""
        self.executor.send_tools({"async_file_tool": EXAMPLE_ASYNC_TOOLS["async_file_tool"]})
        
        code = """
try:
    result = await async_file_tool("read", "nonexistent_file.txt")
    error_occurred = "File not found" in result
except Exception as e:
    error_occurred = True
"""
        
        output, logs, is_final = await self.executor(code)
        # Should handle the error gracefully, not raise exception


class TestSyncToAsyncAdapter:
    """Test SyncToAsyncToolAdapter functionality"""
    
    @pytest.mark.asyncio
    async def test_sync_tool_adaptation(self):
        """Test that sync tools are properly adapted for async execution"""
        from minion.tools.async_base_tool import SyncToAsyncToolAdapter
        
        adapter = SyncToAsyncToolAdapter(sync_test_tool)
        
        # Test the adapter works
        result = await adapter(10, 20)
        assert result == 30
        
        # Test it maintains tool properties
        assert adapter.name == sync_test_tool.name


class TestAsyncFileOperations:
    """Test async file operations"""
    
    @pytest.mark.asyncio
    async def test_file_write_read(self):
        """Test async file write and read operations"""
        from minion.tools.async_example_tools import AsyncFileTool
        import os
        
        file_tool = AsyncFileTool()
        test_file = "test_async_write.txt"
        test_content = "Hello, async world!"
        
        try:
            # Write file
            write_result = await file_tool("write", test_file, test_content)
            assert "Successfully wrote" in write_result
            
            # Read file
            read_result = await file_tool("read", test_file)
            assert read_result == test_content
            
        finally:
            # Cleanup
            if os.path.exists(test_file):
                os.remove(test_file)


class TestAsyncDatabaseOperations:
    """Test async database simulation"""
    
    @pytest.mark.asyncio
    async def test_database_operations(self):
        """Test async database CRUD operations"""
        from minion.tools.async_example_tools import AsyncDatabaseTool
        
        db = AsyncDatabaseTool()
        
        # Test INSERT
        insert_result = await db("INSERT INTO users VALUES (1, 'test')", "INSERT")
        assert insert_result["operation"] == "INSERT"
        assert insert_result["success"] is True
        
        # Test SELECT
        select_result = await db("SELECT * FROM users", "SELECT")
        assert select_result["operation"] == "SELECT"
        assert select_result["count"] >= 1
        
        # Test UPDATE
        update_result = await db("UPDATE users SET name='updated'", "UPDATE")
        assert update_result["operation"] == "UPDATE"
        
        # Test DELETE
        delete_result = await db("DELETE FROM users", "DELETE")
        assert delete_result["operation"] == "DELETE"


@pytest.mark.asyncio
async def test_performance_benefit():
    """Test that async execution provides performance benefits for concurrent operations"""
    import time
    
    executor = AsyncPythonExecutor(additional_authorized_imports=["asyncio", "time"])
    executor.send_tools({"async_fetch_data": EXAMPLE_ASYNC_TOOLS["async_fetch_data"]})
    
    # Concurrent execution
    concurrent_code = """
import asyncio
import time
start_time = time.time()
tasks = [async_fetch_data(f"url_{i}", 0.1) for i in range(3)]
results = await asyncio.gather(*tasks)
end_time = time.time()
execution_time = end_time - start_time
"""
    
    start = time.time()
    output, logs, is_final = await executor(concurrent_code)
    total_time = time.time() - start
    
    # Concurrent execution should complete in less than 0.5 seconds
    # (3 tasks * 0.1s each would be 0.3s if sequential, but should be ~0.1s if concurrent)
    assert total_time < 0.5, f"Concurrent execution took too long: {total_time}s"


if __name__ == "__main__":
    # Run tests with pytest when executed directly
    pytest.main([__file__, "-v"])